// %BANNER_BEGIN%
// ---------------------------------------------------------------------
// %COPYRIGHT_BEGIN%
// <copyright file = "MLAppConnect.cs" company="Magic Leap, Inc">
//
// Copyright (c) 2018-present, Magic Leap, Inc. All Rights Reserved.
//
// </copyright>
// %COPYRIGHT_END%
// ---------------------------------------------------------------------
// %BANNER_END%

namespace UnityEngine.XR.MagicLeap
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Threading;
    #if PLATFORM_LUMIN
    using UnityEngine.XR.MagicLeap.Native;
    #endif

    /// <summary>
    /// Manages App Connections.
    /// </summary>cle
    public sealed class MLAppConnect : MLAPISingleton<MLAppConnect>
    {
        #if PLATFORM_LUMIN

        /// <summary>
        /// Connection Name Key.
        /// Mandatory key in the key-value list returned by #MLAppConnectInviteCallback().
        /// An application invited to a new connection is supposed to obtain the connection name by reading
        /// the value associated with this key.
        /// </summary>
        public const string ConnectionNameKey = "connection_name";

        /// <summary>
        /// Maximum number of participants in a session.
        /// </summary>
        public const uint ConnectionMaxParticipants = 10;

        /// <summary>
        /// The maximum range used to generate a random ID.
        /// </summary>
        private const int MaxRange = 1000;

        /// <summary>
        /// The minimum range used to generate a random ID.
        /// </summary>
        private const int MinRange = 1;

        /// <summary>
        /// The prefix value of the default connection name generated by CreateConnection().
        /// </summary>
        private const string ConnectionNamePrefix = "connection";

        /// <summary>
        /// The internal handle attached to this instance of MLAppConnect invite receiving registration.
        /// </summary>
        private static ulong connectionHandle = MagicLeapNativeBindings.InvalidHandle;

        /// <summary>
        /// The internal handle attached to this instance of MLAppConnect invite receiving registration.
        /// </summary>
        private static ulong inviteHandle = MagicLeapNativeBindings.InvalidHandle;

        /// <summary>
        /// The internal event handle.
        /// </summary>
        private static ulong eventHandle = MagicLeapNativeBindings.InvalidHandle;

        /// <summary>
        /// Default byte that gets populated with new incoming data.
        /// </summary>
        private static byte[] defaultByteArray;

        /// <summary>
        /// Default MLImage that gets populated with new incoming video frame.
        /// </summary>
        private static MLImageNativeBindings.MLImageNative cachedNativeImage = MLImageNativeBindings.MLImageNative.Create();

        /// <summary>
        /// Collection of video pipe names to be read.
        /// </summary>
        private static HashSet<string> videoPipeNames = new HashSet<string>();

        /// <summary>
        /// Determines if the video thread is running;
        /// </summary>
        private static bool videoThreadRunning;

        /// <summary>
        /// Thread used to read video frame asynchronously
        /// </summary>
        private static Thread videoReadThread;

        /// <summary>
        /// Determines if the next video frame is ready to be as an MLImage.
        /// </summary>
        private static bool nextFrameReady;

        /// <summary>
        /// lock used to synchronously update frameData.
        /// </summary>
        private static object balanceLock = new object();

        /// <summary>
        /// Caches the latest video frame for the respective video pipe.
        /// </summary>
        private static ConcurrentDictionary<string, VideoFrameData> frameData = new ConcurrentDictionary<string, VideoFrameData>();

        /// <summary>
        /// Prevents a default instance of the <see cref="MLAppConnect"/> class from being created.
        /// </summary>
        private MLAppConnect()
        {
            ConnectionName = null;
        }

        /// <summary>
        /// ACP Invite callback function.
        /// </summary>
        /// <param name="connection_name">Name of the connection.</param>
        public delegate void OnInviteDelegate(string connection_name);

        /// <summary>
        /// Connection callback function.
        /// </summary>
        /// <param name="result">The result status of the connection.</param>
        /// <param name="connectionName">Name of the connection.</param>
        public delegate void OnConnectionDelegate(MLResult.Code result, string connectionName);

        /// <summary>
        /// Event callback for any changes inside the registered connection relating to microphone, pipe user or connection
        /// </summary>
        /// <param name="eventType">>Type of ACP Event.</param>
        public delegate void OnEventDelegate(EventType eventType);

        /// <summary>
        /// Users Event Callback for the following Events:
        /// User Exited.
        /// User Joined.
        /// User Invite.
        /// User Invite Aborted.
        /// </summary>
        /// <param name="eventType">>Type of User Event.</param>
        /// <param name="userInfo">The user structure containing more information regarding the event.</param>
        public delegate void OnUsersEventDelegate(EventType eventType, UserEventInfo userInfo);

        /// <summary>
        /// Pipe Event Callback for the following Events:
        /// Pipe Created.
        /// Pipe Creation Failed.
        /// Pipe Deleted.
        /// Large Data Sent.
        /// Pipe Blocked
        /// Pipe Unblocked
        /// </summary>
        /// <param name="eventType">Type of Pipe Event.</param>
        /// <param name="pipeInfo">The pipe structure containing more information regarding the event</param>
        public delegate void OnPipeEventDelegate(EventType eventType, PipeEventInfo pipeInfo);

        /// <summary>
        /// Microphone Event Callback for the following Events:
        /// Microphone Unmuted.
        /// Microphone Muted.
        /// </summary>
        /// <param name="eventType">Type of Microphone Event.</param>
        /// <param name="micInfo">The microphone structure containing more information</param>
        public delegate void OnMicrophoneEventDelegate(EventType eventType, MicrophoneEventInfo micInfo);

        /// <summary>
        /// Video Read Callback that sends video frame when ready;
        /// </summary>
        /// <param name="pipeName">Name of the pipe</param>
        /// <param name="videoFrame">The microphone structure containing more information</param>
        public delegate void OnVideoFrameUpdateDelegate(string pipeName, Texture2D videoFrame);

        /// <summary>
        /// Video Read Callback that sends video frame when ready;
        /// </summary>
        public static event OnVideoFrameUpdateDelegate OnVideoFrameUpdate = delegate { };

        /// <summary>
        /// Microphone Event Callback for the following Events:
        /// Microphone Unmuted.
        /// Microphone Muted.
        /// </summary>
        public static event OnPipeEventDelegate OnPipeEvent
        {
            add
            {
                MLAppConnectNativeBindings.OnPipeEvent += value;
            }

            remove
            {
                MLAppConnectNativeBindings.OnPipeEvent -= value;
            }
        }

        /// <summary>
        /// Users Event Callback for the following Events:
        /// User Exited.
        /// User Joined.
        /// User Invite.
        /// User Invite Aborted.
        /// </summary>
        public static event OnUsersEventDelegate OnUsersEvent
        {
            add
            {
                MLAppConnectNativeBindings.OnUsersEvent += value;
            }

            remove
            {
                MLAppConnectNativeBindings.OnUsersEvent -= value;
            }
        }

        /// <summary>
        /// Microphone Event Callback for the following Events:
        /// Microphone Unmuted.
        /// Microphone Muted.
        /// </summary>
        public static event OnMicrophoneEventDelegate OnMicrophoneEvent
        {
            add
            {
                MLAppConnectNativeBindings.OnMicrophoneEvent += value;
            }

            remove
            {
                MLAppConnectNativeBindings.OnMicrophoneEvent -= value;
            }
        }

        /// <summary>
        /// On connection event.
        /// </summary>
        public static event OnConnectionDelegate OnConnection
        {
            add
            {
                MLAppConnectNativeBindings.OnConnection += value;
            }

            remove
            {
                MLAppConnectNativeBindings.OnConnection -= value;
            }
        }

        /// <summary>
        /// Connection Invite event.
        /// </summary>
        public static event OnInviteDelegate OnInvite
        {
            add
            {
                MLAppConnectNativeBindings.OnInvite += value;
            }

            remove
            {
                MLAppConnectNativeBindings.OnInvite -= value;
            }
        }

        /// <summary>
        /// Event Info.
        /// </summary>
        public static event OnEventDelegate OnEvent
        {
            add
            {
                MLAppConnectNativeBindings.OnEvent += value;
            }

            remove
            {
                MLAppConnectNativeBindings.OnEvent -= value;
            }
        }

#endif

        /// <summary>
        /// This is the C# representation of MLAppConnectConnectionType from #ml_app_connect.h.
        /// Type of connection to be created.
        /// </summary>
        public enum ConnectionType
        {
            /// <summary>
            /// Unknown connection type.
            /// </summary>
            UnknownConnectionType,

            /// <summary>
            /// Loopback Connection.
            /// </summary>
            Loopback,

            /// <summary>
            /// Connection with default WebRTC.
            /// </summary>
            Default
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectPipeType from #ml_app_connect.h.
        /// The type of media pipe to send/receive data with remote users.
        /// </summary>
        public enum PipeType
        {
            /// <summary>
            /// Unknown Pipe type.
            /// </summary>
            UnknownPipeType,

            /// <summary>
            /// Pipe type for Audio transfer.
            /// </summary>
            AudioPipe,

            /// <summary> Pipe type for Data transfer.
            /// </summary>
            DataPipe,

            /// <summary>
            /// Pipe type for Video transfer.
            /// </summary>
            VideoPipe
        }

        /// <summary>
        /// The reliability of the pipe.
        /// </summary>
        public enum PipeReliability
        {
            /// <summary>
            /// Unknown reliability.
            /// </summary>
            UnknownPipeReliability,

            /// <summary>
            /// Reliable data transfer.
            /// </summary>
            Reliable,

            /// <summary>
            /// Unreliable data transfer.
            /// </summary>
            Unreliable
        }

        /// <summary>
        /// The data ordering of the pipe.
        /// </summary>
        public enum PipeOrdering
        {
            /// <summary>
            /// Unknown order.
            /// </summary>
            UnknownPipeOrdering,

            /// <summary>
            /// Data transfer in order.
            /// </summary>
            Ordered,

            /// <summary>
            /// Data transfer not in order.
            /// </summary>
            NotOrdered
        }

        /// <summary>
        /// The direction of data flow in a pipe.
        /// </summary>
        public enum PipeDirection
        {
            /// <summary>
            /// Pipe direction, Unknown.
            /// </summary>
            UnknownPipeDirection,

            /// <summary>
            /// Pipe direction, <c>UniDirection</c> out.
            /// </summary>
            UniDirectionalOut,

            /// <summary>
            /// Pipe direction, <c>UniDirection</c> in.
            /// </summary>
            UniDirectionalIn,

            /// <summary>
            /// Pipe direction, BiDirection.
            /// </summary>
            BiDirectional,
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectPriority from #ml_app_connect.h
        /// Before the data is actually sent to other users, it gets queued according to a priority.
        /// If 2 pipes with different priorities have queued data at the same time, then the pipe
        /// with the higher priority will flush its data before the pipe with lower priority.
        /// </summary>
        public enum Priority
        {
            /// <summary>
            /// priority, High.
            /// </summary>
            High,

            /// <summary>
            /// priority, Normal.
            /// </summary>
            Normal,

            /// <summary>
            /// priority, Low.
            /// </summary>
            Low
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectConnectionEventType from #ml_app_connect.h
        /// The AppConnect event types that can be reported to client applications.
        /// </summary>
        public enum EventType
        {
            /// <summary>
            /// Unknown Event.
            /// </summary>
            UnknownEvent,

            /// <summary>
            /// Pipe Created.
            /// </summary>
            PipeCreated,

            /// <summary>
            /// Pipe Creation Failed.
            /// </summary>
            PipeFailed,

            /// <summary>
            /// Pipe Deleted.
            /// </summary>
            PipeDeleted,

            /// <summary>
            /// Pipe received large data packet(s).
            /// </summary>
            PipeLargeData,

            /// <summary>
            /// Microphone Muted.
            /// </summary>
            MicMuted,

            /// <summary>
            /// Microphone Unmuted.
            /// </summary>
            MicUnmuted,

            /// <summary>
            /// Contact joined the connection.
            /// </summary>
            UserJoined,

            /// <summary>
            /// Contact left the connection.
            /// </summary>
            UserExited,

            /// <summary>
            /// A new user got invited.
            /// </summary>
            UserInvite,

            /// <summary>
            /// User decided to abort the "invite dialog".
            /// </summary>
            UsersInviteAbort,
        }

        /// <summary>
        /// Video format.
        /// </summary>
        public enum VideoFormat
        {
            /// <summary>
            /// RGBA format.
            /// </summary>
            RGBA,

            /// <summary>
            /// I420 video format.
            /// </summary>
            I420
        }

#if PLATFORM_LUMIN

        /// <summary>
        /// Gets or sets Name of the connection used either used to create the connection or join an existing one.
        /// The field will be populated once a connection has been successfully created.
        /// </summary>
        public static string ConnectionName { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether Determines if the connection has been joined or created.
        /// </summary>
        public static bool IsConnectionActive { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether Determines if the connection was created by the current user.
        /// </summary>
        public static bool IsOwner { get; set; }

        /// <summary>
        /// Start the MLAppConnect API. This will register and set callbacks for receiving an ACP invite and creating a ACP connection.
        /// </summary>
        /// <returns>
        /// MLResult_Ok if successfully started.
        /// </returns>
        public static MLResult Start()
        {
            CreateInstance();
            return MLAppConnect.BaseStart();
        }

        /// <summary>
        /// Create connection.
        /// Initial step to create a new connection.
        /// Invoking this function will start by displaying the "invite dialog" interface in the "initiator device".
        /// The user will be able to invite one or more of their users to the connection.Each one of the invited
        /// user will then receive a system notification to be accepted or declined.
        /// A connection callback (registered by #MLAppConnectRegisterConnectionCallback()) should be
        /// set up before calling this function.
        /// </summary>
        /// <param name="connectionName">Name of the connection</param>
        /// <param name="type">The connection type.</param>
        /// <param name="connectionPriority">The priority of the connection.</param>
        /// <param name="maxParticipants">Max number of participants allowed in the connection.</param>
        /// <param name="lockUsers">Set boolean for other participants to not have access rights to invite other users.</param>
        /// <param name="lockPipes">Set boolean for other participants to not have access rights to create pipes.</param>
        /// <returns>
        /// MLResult_Ok if successfully created a connection, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult CreateConnection(string connectionName, ConnectionType type, Priority connectionPriority, uint maxParticipants, bool lockUsers, bool lockPipes)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    ConnectionName = connectionName;
                    ConnectionProperties connectionProperties = ConnectionProperties.Create();
                    connectionProperties.Type = type;
                    connectionProperties.Priority = connectionPriority;
                    connectionProperties.MaxParticipants = maxParticipants;
                    connectionProperties.LockContacts = lockUsers;
                    connectionProperties.LockPipes = lockPipes;

                    if (MagicLeapNativeBindings.MLHandleIsValid(inviteHandle))
                    {
                        MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectCreateConnection(connectionName, ref connectionProperties);
                        if (!MLResult.IsOK(resultCode))
                        {
                            MLResult resultError = MLResult.Create(resultCode);

                            MLPluginLog.ErrorFormat("MLAppConnect.CreateConnection failed to create a new connection, Reason: {0}", resultError);

                            return resultError;
                        }

                        return MLResult.Create(resultCode);
                    }
                    else
                    {
                        MLPluginLog.ErrorFormat("MLAppConnect.CreateConnection failed to create a new connection, Reason: InviteHandle is invalid");
                        return MLResult.Create(MLResult.Code.UnspecifiedFailure, " Reason: InviteHandle is invalid");
                    }
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.UpdateState failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.UpdateState failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.CreateConnection failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateConnection failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
}

        /// <summary>
        /// Create connection using the  default connection properties.
        /// Initial step to create a new connection.
        /// Invoking this function will start by displaying the "invite dialog" interface in the "initiator device".
        /// The user will be able to invite one or more of their users to the connection.Each one of the invited
        /// user will then receive a system notification to be accepted or declined.
        /// A connection callback (registered by #MLAppConnectRegisterConnectionCallback()) should be
        /// set up before calling this function.
        /// </summary>
        /// <returns>
        /// MLResult_Ok if successfully created a connection, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult CreateConnection()
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    ConnectionProperties connectionProperties = ConnectionProperties.Create();

                    if (MagicLeapNativeBindings.MLHandleIsValid(inviteHandle))
                    {
                        MLResult.Code resultCode;
                        //// Attempts to create a unique connection name by adding a random postfix to the connection.
                        do
                        {
                            string connectionNamePostfix = new Random().Next(MinRange, MaxRange).ToString();
                            ConnectionName = ConnectionNamePrefix + connectionNamePostfix;
                            resultCode = MLAppConnectNativeBindings.MLAppConnectCreateConnection(ConnectionName, ref connectionProperties);
                        }
                        while (resultCode == MLResult.Code.AppConnectConnectionExists);

                        if (!MLResult.IsOK(resultCode))
                        {
                            MLResult resultError = MLResult.Create(resultCode);
                            MLPluginLog.ErrorFormat("MLAppConnect.CreateConnection failed to create a new connection, Reason: {0}", resultError);
                            return resultError;
                        }

                        return MLResult.Create(resultCode);
                    }
                    else
                    {
                        MLPluginLog.ErrorFormat("MLAppConnect.CreateConnection failed to create a new connection, Reason: InviteHandle is invalid");

                        return MLResult.Create(MLResult.Code.UnspecifiedFailure, " Reason: InviteHandle is invalid");
                    }
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.CreateConnection failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateConnection failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.CreateConnection failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateConnection failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Invite users.
        /// This function is similar #MLAppConnectCreateConnection(), but works with an ongoing connection.
        /// It will also display the "invite dialog" and allow the user to invite more contacts.
        /// A connection event callback (registered by #MLAppConnectRegisterEventCallback()) should be
        /// set up before calling this function.
        /// </summary>
        /// <returns>
        /// MLResult_Ok if successful, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult InviteUsers()
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    if (MagicLeapNativeBindings.MLHandleIsValid(connectionHandle))
                    {
                        MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectInviteUsers(ConnectionName);

                        if (!MLResult.IsOK(resultCode))
                        {
                            MLResult resultError = MLResult.Create(resultCode);

                            MLPluginLog.ErrorFormat("MLAppConnect.InviteUsers failed to invite a new user, Reason: {0}", resultError);

                            return resultError;
                        }

                        return MLResult.Create(resultCode);
                    }
                    else
                    {
                        MLPluginLog.ErrorFormat("MLAppConnect.InviteUsers failed to invite a new user, Reason: EventHandle is invalid");
                        return MLResult.Create(MLResult.Code.UnspecifiedFailure, " Reason: EventnHandle is invalid");
                    }
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.InviteUsers failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.InviteUsers failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.InviteUsers failed to invite a new user. Reason: No Instance for MLAppConnect");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.InviteUsers failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Co-join connection.
        /// Once a user is invited to join some specific connection, a system notification will be displayed
        /// and the user will be able to accept or decline.
        /// If the invite is accepted, the corresponding app will load and be ready to join the connection.
        /// The callback #MLAppConnectInviteCallback will then be triggered and bring any information related
        /// to the connection. In special, the "connection name" used by <c>#MLAppConnectCojoinConnection()</c>.
        /// A connection callback (registered by <c>#MLAppConnectRegisterConnectionCallback())</c> should be
        /// set up before calling this function.
        /// </summary>
        /// <returns>
        /// MLAppConnectResult_Ok if successfully unblocked a pipe, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult CojoinConnection()
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    if (MagicLeapNativeBindings.MLHandleIsValid(connectionHandle))
                    {
                        MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectCojoinConnection(ConnectionName);

                        if (!MLResult.IsOK(resultCode))
                        {
                            MLResult resultError = MLResult.Create(resultCode);

                            MLPluginLog.ErrorFormat("MLAppConnect.CojoinConnection failed to cojoin a connection, Reason: {0}", resultError);

                            return resultError;
                        }

                        return MLResult.Create(resultCode);
                    }
                    else
                    {
                        MLPluginLog.ErrorFormat("MLAppConnect.CojoinConnection failed to cojoin a connection, Reason: ConnectionHandle is invalid");

                        return MLResult.Create(MLResult.Code.UnspecifiedFailure, " Reason: ConnectionHandle is invalid");
                    }
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.CojoinConnection failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CojoinConnection failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.CojoinConnection failed to cojoin a connection. Reason: No Instance for MLAppConnect");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CojoinConnection failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Delete connection.
        /// </summary>
        /// <returns>
        /// MLResult_Ok if successfully deleted a connection, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult DeleteConnection()
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode;

                    if (MagicLeapNativeBindings.MLHandleIsValid(eventHandle))
                    {
                        resultCode = MLAppConnectNativeBindings.MLAppConnectUnregisterEventCallback(ConnectionName, eventHandle);

                        if (!MLResult.IsOK(resultCode))
                        {
                            MLPluginLog.ErrorFormat("MLAppConnect.DeleteConnection failed to shutdown registration to receive events. Reason: {0}", MLResult.CodeToString(resultCode));
                        }

                        eventHandle = MagicLeapNativeBindings.InvalidHandle;
                    }

                    resultCode = MLAppConnectNativeBindings.MLAppConnectDeleteConnection(ConnectionName);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);

                        MLPluginLog.ErrorFormat("MLAppConnect.DeletConnection failed to delete connection, Reason: {0}", resultError);

                        return resultError;
                    }

                    ConnectionName = string.Empty;
                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.DeleteConnection failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.DeleteConnection failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.DeleteConnection failed to delete connection. Reason: No Instance for MLAppConnect");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.DeleteConnection failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Create data pipe.
        /// Creates a "general purpose" data pipe.The functions #MLAppConnectSendData() and #MLAppConnectReadData() should
        /// be used to write to and read from this pipe.
        /// </summary>
        /// <param name="pipeName">The name of the pipe to create.</param>
        /// <param name="dataPipe">The data pipe properties for this pipe.</param>
        /// <returns>
        /// MLResult_Ok if successfully created a pipe, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult CreateDataPipe(string pipeName, DataPipeProperties dataPipe)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectCreateDataPipe(ConnectionName, pipeName, ref dataPipe);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);

                        MLPluginLog.ErrorFormat("MLAppConnect.CreateDataPipe failed to create a new data pipe, Reason: {0}", resultError);

                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.CreateDataPipe failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateDataPipe failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.DeleteConnection failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.DeleteConnection failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Create data pipe.
        /// Creates a "general purpose" data pipe.The functions #MLAppConnectSendData() and #MLAppConnectReadData() should
        /// be used to write to and read from this pipe.
        /// </summary>
        /// <param name="pipeName">The name of the pipe to create.</param>
        /// <returns>
        /// MLResult_Ok if successfully created a pipe, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult CreateDataPipe(string pipeName)
        {
            DataPipeProperties dataPipe = DataPipeProperties.Create();

            return CreateDataPipe(pipeName, dataPipe);
        }

        /// <summary>
        /// Create video pipe.
        /// Creates a "video specialized" data pipe.The functions #MLAppConnectSendVideoFrame() and
        /// #MLAppConnectReadVideoFrame() should be used to write to and read from this pipe.
        /// </summary>
        /// <param name="pipeName">pipe_name The name of the pipe to create </param>
        /// <param name="videoPipe">Properties of the video pipe to be set</param>
        /// <returns>
        ///  MLResult_Ok if successfully created a pipe, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult CreateVideoPipe(string pipeName, VideoPipeProperties videoPipe)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {


                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectCreateVideoPipe(ConnectionName, pipeName, ref videoPipe);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);

                        MLPluginLog.ErrorFormat("MLAppConnect.CreateVideoPipe failed to create a new video pipe, Reason: {0}", resultError);

                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.CreateVideoPipe failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateVideoPipe failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.CreateVideoPipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateVideoPipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Create video pipe.
        /// Creates a "video specialized" data pipe.The functions #MLAppConnectSendVideoFrame() and
        /// #MLAppConnectReadVideoFrame() should be used to write to and read from this pipe.
        /// </summary>
        /// <param name="pipeName">pipe_name The name of the pipe to create. </param>
        /// <returns>
        ///  MLResult_Ok if successfully created a pipe, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult CreateVideoPipe(string pipeName)
        {
            VideoPipeProperties videoPipe = VideoPipeProperties.Create();
            return CreateVideoPipe(pipeName, videoPipe);
        }

        /// <summary>
        /// This function should be called to delete a "data pipe" or a "video pipe" or an "audio pipe".
        /// This function should NOT be used to delete "video capture pipe" or "microphone audio pipe".
        /// For these, use <c>#MLAppConnectDeleteVideoCapturePipe()</c> and <c>#MLAppConnectDeleteMicAudioPipe()</c> instead.
        /// </summary>
        /// <param name="pipeName">The name of the pipe to delete.</param>
        /// <returns>
        /// MLResult_Ok if successfully deleted the pipe, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult DeletePipe(string pipeName)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectDeletePipe(ConnectionName, pipeName);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);

                        MLPluginLog.ErrorFormat("MLAppConnect.DeletePipe failed to delete pipe, Reason: {0}", resultError);

                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.DeletePipe failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.DeletePipe failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.DeletePipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.DeletePipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Create video capture pipe.
        /// Creates a "video capture specialized" data pipe.
        /// No function should be used to write to this pipe.It is managed and fed automatically with frames.
        /// from the device's camera.
        /// The other peers of the connection should use #MLAppConnectReadVideoFrame() to read the video frames
        /// from this pipe.From the receiver side, a "video capture pipe" is no different than a "regular video pipe".
        /// </summary>
        /// <param name="videoPipe">The name of the pipe to delete.</param>
        /// <returns>
        /// MLResult_Ok if successfully created a pipe, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult CreateVideoCapturePipe(VideoPipeProperties videoPipe)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectCreateVideoCapturePipe(ConnectionName, ref videoPipe);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.CreateVideoCapturePipe failed to create a new video capture pipe, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.CreateVideoCapturePipe failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateVideoCapturePipe failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.CreateVideoCapturePipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateVideoCapturePipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Create video capture pipe.
        /// Creates a "video capture specialized" data pipe.
        /// No function should be used to write to this pipe.It is managed and fed automatically with frames.
        /// from the device's camera.
        /// The other peers of the connection should use #MLAppConnectReadVideoFrame() to read the video frames
        /// from this pipe.From the receiver side, a "video capture pipe" is no different than a "regular video pipe".
        /// </summary>
        /// <returns>
        /// MLResult_Ok if successfully created a pipe, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult CreateVideoCapturePipe()
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    VideoPipeProperties videoPipe = VideoPipeProperties.Create();
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectCreateVideoCapturePipe(ConnectionName, ref videoPipe);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.CreateVideoCapturePipe failed to create a new video capture pipe, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.CreateVideoCapturePipe failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateVideoCapturePipe failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.CreateVideoCapturePipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateVideoCapturePipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Delete video capture pipe.
        /// </summary>
        /// <returns>
        /// MLResult_Ok if successfully deleted a pipe, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult DeleteVideoCapturePipe()
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectDeleteVideoCapturePipe(ConnectionName);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);

                        MLPluginLog.ErrorFormat("MLAppConnect.DeleteVideoCapturePipe failed to delete video capture pipe, Reason: {0}", resultError);

                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.DeleteVideoCapturePipe failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.DeleteVideoCapturePipe failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.DeleteVideoCapturePipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.DeleteVideoCapturePipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Create microphone audio pipe.
        /// </summary>
        /// <returns>
        /// MLResult_Ok if successfully created a pipe, error code from <c>#MLAppConnectResult</c> otherwise.
        /// </returns>
        public static MLResult CreateMicAudioPipe()
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectCreateMicAudioPipe(ConnectionName);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);

                        MLPluginLog.ErrorFormat("MLAppConnect.CreateMicAudioPipe failed to create an audio pipe, Reason: {0}", resultError);

                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.CreateMicAudioPipe failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateMicAudioPipe failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.CreateMicAudioPipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.CreateMicAudioPipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Delete the audio pipe for the (internally managed) microphone from the connection..
        /// </summary>
        /// <returns>
        /// MLResult_Ok if successfully deleted a pipe, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult DeleteMicAudioPipe()
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectDeleteMicAudioPipe(ConnectionName);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);

                        MLPluginLog.ErrorFormat("MLAppConnect.DeleteMicAudioPipe failed to delete a audio pipe, Reason: {0}", resultError);

                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.DeleteMicAudioPipe failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.DeleteMicAudioPipe failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.DeleteMicAudioPipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.DeleteMicAudioPipe failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Mute the microphone for the connection.
        /// </summary>
        /// <returns>
        /// MLResult_Ok if successfully muted a pipe, error code from #MLAppConnectResult otherwise
        /// </returns>
        public static MLResult MuteMic()
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectMuteMic(ConnectionName);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.MuteMic failed to mute mic audio, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.MuteMic failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.MuteMic failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.MuteMic failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.MuteMic failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// UnMute the microphone for the connection.
        /// </summary>
        /// <returns>
        /// LResult_Ok if successfully muted a pipe, error code from <c>#MLAppConnectResult</c> otherwise
        /// </returns>
        public static MLResult UnmuteMic()
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectUnmuteMic(ConnectionName);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.UnmuteMic failed to unmute mic audio, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.UnmuteMic failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.UnmuteMic failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.UnmuteMic failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.UnmuteMic failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Check if the microphone is muted for the the connection.
        /// </summary>
        /// <param name="isMuted">out: if the Microphone is muted.</param>
        /// <returns>
        /// MLResult_Ok if successfully returned the value, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult IsMicMuted(out bool isMuted)
        {
            isMuted = false;

            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectIsMicMuted(ConnectionName, ref isMuted);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.IsMicMuted failed to detect if mic is muted, Reason: {0}", resultError);
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.IsMicMuted failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.IsMicMuted failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.IsMicMuted failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.IsMicMuted failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Mute user.
        /// Mute audio from another user.
        /// </summary>
        /// <param name="user">The user name.</param>
        /// <returns>
        /// MLResult_Ok if successfully returned the value, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult MuteUser(string user)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectMuteUser(ConnectionName, user);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.MuteUser failed to mute user, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.MuteUser failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.MuteUser failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.IsMicMuted failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.IsMicMuted failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Mute user.
        /// Mute audio from another user.
        /// </summary>
        /// <param name="user">The user name.</param>
        /// <returns>
        /// MLResult_Ok if successfully returned the value, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult UnmuteUser(string user)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectUnmuteUser(ConnectionName, user);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.UnmuteMic failed to unmute user, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.UnmuteUser failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.UnmuteUser failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.UnmuteUser failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.UnmuteUser failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Send a byte array.
        /// This function should be called to send data over a pipe.
        /// </summary>
        /// <param name="pipeName">The name of the pipe to send the data.</param>
        /// <param name="byteArray">The data to be sent.</param>
        /// <returns>
        /// MLResult_Ok if successfully sent data, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult SendData(string pipeName, byte[] byteArray)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    IntPtr data = Marshal.AllocHGlobal(byteArray.Length);
                    Marshal.Copy(byteArray, 0, data, byteArray.Length);
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectSendData(ConnectionName, pipeName, data, (ulong)byteArray.Length);
                    MLPluginLog.DebugFormat("Size of data: {0}", Marshal.SizeOf(data));
                    Marshal.FreeHGlobal(data);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.SendData failed to send data, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.SendData failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.SendData failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.SendData failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.SendData failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Send Large data over a pipe.
        /// Send Large data(>IP MTU) to a pipe of this connection.
        /// </summary>
        /// <param name="pipeName">Name of the pipe</param>
        /// <param name="byteArray">The name of the pipe to send the data.</param>
        /// <returns>
        /// MLResult_Ok if successfully sent data, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult SendLargeData(string pipeName, byte[] byteArray)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    IntPtr data = Marshal.AllocHGlobal(byteArray.Length);
                    Marshal.Copy(byteArray, 0, data, byteArray.Length);
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectSendLargeData(ConnectionName, pipeName, data, (ulong)byteArray.Length);
                    Marshal.FreeHGlobal(data);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.SendLargeData failed to send large data, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.SendLargeData failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.SendLargeData failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.SendLargeData failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.SendLargeData failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Read data.
        /// This function will block the execution until at least #min_bytes are read from the pipe.
        /// #min_bytes can also be set to 0 and this function will return immediately with or without
        /// any incoming data.
        /// </summary>
        /// <param name="pipeName">The name of the pipe to read the data.</param>
        /// <param name="byteArray">The data read from the pipe.</param>
        /// <param name="minBytes">The minimum size of the data that needs to read before returning.</param>
        /// <returns>
        /// MLResult_Ok if successfully read data, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult GetData(string pipeName, out byte[] byteArray, uint minBytes = 0)
        {
            byteArray = null;

            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLAppConnectNativeBindings.ReadDataParameters readDataParameters = MLAppConnectNativeBindings.ReadDataParameters.Create();
                    readDataParameters.MinBytes = minBytes;
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectReadData(ConnectionName, pipeName, ref readDataParameters);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.Getdata failed to read data, Reason: {0}", resultError);
                        return resultError;
                    }
                    else if (readDataParameters.DataSize > 0 && readDataParameters.Data != IntPtr.Zero)
                    {
                        byteArray = new byte[readDataParameters.DataSize];
                        Marshal.Copy(readDataParameters.Data, byteArray, 0, (int)readDataParameters.DataSize);

                        resultCode = MLAppConnectNativeBindings.MLAppConnectFreeData(readDataParameters.Data);
                        if (!MLResult.IsOK(resultCode))
                        {
                            MLResult resultError = MLResult.Create(resultCode);
                            MLPluginLog.ErrorFormat("MLAppConnect.GetData failed to free data after a successful read, Reason: {0}", resultError);
                            return resultError;
                        }
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.GetData failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.GetData failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.GetData failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.GetData failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Read Large.
        /// [non-blocking; ownership of memory is transferred to the client]
        /// Read (large) data from a pipe of this connection. Due to fragmentation and reassembly
        /// of large datagrams when calling this API there is no guarantee that this datagram is received
        /// in order with data that is sent using the Send API, MLAppConnectSendLarge().
        /// </summary>
        /// <param name="pipeName">The name of the pipe to read the data.</param>
        /// <param name="byteArray">Address of data read from the pipe.</param>
        /// <param name="packetsRemaining">The number of packets remaining.</param>
        /// <returns>
        /// MLResult_Ok if successfully read data, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult GetLargeData(string pipeName, out byte[] byteArray, out ulong packetsRemaining)
        {
            byteArray = null;
            packetsRemaining = 0;

            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLAppConnectNativeBindings.ReadLargeDataParameters readLargeDataParameters = MLAppConnectNativeBindings.ReadLargeDataParameters.Create();
                    packetsRemaining = readLargeDataParameters.DataPacketsRemaining;
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectReadLargeData(ConnectionName, pipeName, ref readLargeDataParameters);

                    if (!MLResult.IsOK(resultCode))
                    {
                        byteArray = null;
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.GetLargeData failed to read Data, Reason: {0}", resultError);
                        return resultError;
                    }
                    else if (readLargeDataParameters.DataSize > 0 && readLargeDataParameters.Data != IntPtr.Zero)
                    {
                        byteArray = new byte[readLargeDataParameters.DataSize];
                        Marshal.Copy(readLargeDataParameters.Data, byteArray, 0, (int)readLargeDataParameters.DataSize);
                        packetsRemaining = readLargeDataParameters.DataPacketsRemaining;

                        resultCode = MLAppConnectNativeBindings.MLAppConnectFreeLargeData(readLargeDataParameters.Data);
                        if (!MLResult.IsOK(resultCode))
                        {
                            MLResult resultError = MLResult.Create(resultCode);
                            MLPluginLog.ErrorFormat("MLAppConnect.GetLargeData failed to free large data after a successful read, Reason: {0}", resultError);
                            return resultError;
                        }
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.GetLargeData failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.GetLargeData failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.GetLargeData failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.GetLargeData failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Send video frame.
        /// This function should be called to send video data over a pipe.
        /// </summary>
        /// <param name="pipeName">The name of the pipe to send the data.</param>
        /// <param name="videoFrame">The video frame.</param>
        /// <param name="imageType">The Image type of the texture.</param>
        /// <returns>
        /// MLResult_Ok if successfully sent data, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult SendVideoFrame(string pipeName, Texture2D videoFrame, MLImageNativeBindings.MLImageType imageType = MLImageNativeBindings.MLImageType.RGBA32)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    byte[] imageData = MLTextureUtils.ConvertToByteArray(videoFrame, out int numChannels);
                    MLImageNativeBindings.MLImageNative nativeImage = new MLImageNativeBindings.MLImageNative
                    {
                        ImageType = imageType,
                        Alignment = 1,
                        Width = (uint)videoFrame.width,
                        Height = (uint)videoFrame.height,
                        Image = Marshal.AllocHGlobal(imageData.Length)
                    };
                    Marshal.Copy(imageData, 0, nativeImage.Image, imageData.Length);
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectSendVideoFrame(ConnectionName, pipeName, ref nativeImage);
                    Marshal.FreeHGlobal(nativeImage.Image);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.SendVideoFrame failed to send frame, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.SendVideoFrame failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.SendVideoFrame failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.SendVideoFrame failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.SendVideoFrame failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Read a video frame from a video pipe and Free data buffers allocated by MLAppConnectReadVideoFrame().
        /// This will fill up out_video_frame structure with data related to the video frame.
        /// </summary>
        /// <param name="pipeName">The name of the pipe to read the data.</param>
        /// <param name="videoFrame">[out] New Video frame read as a Texture 2D</param>
        /// <param name="waitForNextFrame">Wait for next video frame to be read before returning.</param>
        /// <returns>
        /// MLResult_Ok if successfully read data, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult GetVideoFrame(string pipeName, out Texture2D videoFrame, bool waitForNextFrame = false)
        {
            videoFrame = null;

            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectReadVideoFrame(ConnectionName, pipeName, waitForNextFrame, out cachedNativeImage);

                    if (!MLResult.IsOK(resultCode))
                    {
                        cachedNativeImage.Image = IntPtr.Zero;
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.GetVideoFrame failed to read frame, Reason: {0}", resultError);
                        return resultError;
                    }
                    else if (cachedNativeImage.Image != IntPtr.Zero)
                    {
                        TextureFormat texFormat = cachedNativeImage.ImageType == MLImageNativeBindings.MLImageType.RGB24 ? TextureFormat.RGB24 : TextureFormat.RGBA32;
                        videoFrame = new Texture2D((int)cachedNativeImage.Width, (int)cachedNativeImage.Height, texFormat, false, false);

                        uint size = cachedNativeImage.Width * cachedNativeImage.Height;
                        size = cachedNativeImage.ImageType == MLImageNativeBindings.MLImageType.RGB24 ? (size * 3) : (size * 4);

                        videoFrame.LoadRawTextureData(cachedNativeImage.Image, (int)size);
                        videoFrame.Apply();
                        resultCode = MLAppConnectNativeBindings.MLAppConnectFreeVideoFrame(ref cachedNativeImage);
                        if (!MLResult.IsOK(resultCode))
                        {
                            cachedNativeImage.Image = IntPtr.Zero;
                            MLResult resultError = MLResult.Create(resultCode);
                            MLPluginLog.ErrorFormat("MLAppConnect.GetVideoFrame failed to free video frame after a successful read, Reason: {0}", resultError);
                            return resultError;
                        }
                    }
                    else
                    {
                        MLPluginLog.DebugFormat(" MLAppConnect.GetVideoFrame failed to read beacuse MLImageNative is null");
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.GetVideoFrame failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.GetVideoFrame failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.GetVideoFrame failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.GetVideoFrame failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Starts a thread to read video frame asynchronously.
        /// OnVideoFrameUpdate event will be triggered once the frame is ready.
        /// </summary>
        /// <param name="pipeName">The name of the pipe.</param>
        public static void StartVideoFrameRead(string pipeName)
        {
            lock (balanceLock)
            {
                if (MLAppConnect.IsValidInstance())
                {
                    videoPipeNames.Add(pipeName);

                    if (!videoThreadRunning && videoPipeNames.Count >= 1)
                    {
                        videoThreadRunning = true;
                        videoReadThread = new Thread(VideoThreadWork);
                        videoReadThread.Start();
                    }
                }
                else
                {
                    MLPluginLog.ErrorFormat("MLAppConnect.StartVideoFrameRead failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                }
            }
        }

        /// <summary>
        /// Stops reading video frame from the specified pipe.
        /// </summary>
        /// <param name="pipeName">Name of the pipe</param>
        public static void StopVideoFrameRead(string pipeName)
        {
            if (MLAppConnect.IsValidInstance())
            {
                lock (balanceLock)
                {
                    videoPipeNames.Remove(pipeName);
                    frameData.TryRemove(pipeName, out VideoFrameData videoFrame);

                    if (videoThreadRunning && videoPipeNames.Count == 0)
                    {
                        videoThreadRunning = false;
                        frameData.Clear();
                    }
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.StopVideoFrameRead failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Pipes can be blocked by #MLAppConnectReadData(), #MLAppConnectReadLargeData() or #MLAppConnectReadVideoFrame().
        /// This happens, for example, when the application requests to read an amount of bytes and this amount isn't available yet.
        /// In this scenario the reader function will block the execution. Another thread can then use #MLAppConnectUnblockRead()
        /// to unblock it.
        /// <param name="pipeName">The pipe name.</param>
        /// <returns>
        /// MLResult_Ok if successfully unblocks read data, error code from #MLAppConnectResult otherwise.
        /// </returns>
        /// </summary>
        public static MLResult UnblockRead(string pipeName)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectUnblockRead(ConnectionName, pipeName);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.UnblockRead failed to unblock read, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.UnblockRead failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.UnblockRead failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.UnblockRead failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.UnblockRead failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Get Participants.
        /// Get a list of participants in an ongoing connection.
        /// </summary>
        /// <param name="participantList">The list of participants in this connection.</param>
        /// <returns>
        /// MLResult_Ok if successfully able to get the participants
        /// error code from #MLAppConnectResult otherwise
        /// </returns>
        public static MLResult GetParticipantList(out string[] participantList)
        {
            participantList = null;

            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    IntPtr unmanagedParticipantList = IntPtr.Zero;
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectGetParticipants(ConnectionName, out unmanagedParticipantList, out uint count);

                    IntPtr[] participantIntPtrArray = new IntPtr[count];
                    participantList = new string[count];

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.GetParticipantList failed to read participant names, Reason: {0}", resultError);
                        return resultError;
                    }

                    Marshal.Copy(unmanagedParticipantList, participantIntPtrArray, 0, (int)count);

                    for (int i = 0; i < count; i++)
                    {
                        participantList[i] = Marshal.PtrToStringAnsi(participantIntPtrArray[i]);
                    }

                    resultCode = MLAppConnectNativeBindings.MLAppConnectFreeParticipants(unmanagedParticipantList, count);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.GetParticipantList failed to free participant names, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.GetParticipantList failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.GetParticipantList failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.GetParticipantList failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.GetParticipantList failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Get a list of strings with the pipe names.
        /// </summary>
        /// <param name="pipeNames">The list of pipe names.</param>
        /// <returns>
        /// MLResult_Ok if successfully returned the value, error code from #MLAppConnectResult otherwise.
        /// </returns>
        public static MLResult GetPipeNames(out string[] pipeNames)
        {
            pipeNames = null;
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    IntPtr unmanagedPipeList = IntPtr.Zero;
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectGetPipeNames(ConnectionName, out unmanagedPipeList, out uint count);

                    IntPtr[] pipeIntPtrArray = new IntPtr[count];
                    pipeNames = new string[count];

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.GetPipeNames failed to read pipe neame, Reason: {0}", resultError);
                        return resultError;
                    }

                    Marshal.Copy(unmanagedPipeList, pipeIntPtrArray, 0, (int)count);

                    for (int i = 0; i < count; i++)
                    {
                        pipeNames[i] = Marshal.PtrToStringAnsi(pipeIntPtrArray[i]);
                    }

                    resultCode = MLAppConnectNativeBindings.MLAppConnectFreePipeNames(unmanagedPipeList, count);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.GetPipeNames failed to free pipe names, Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.GetPipeNames failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.GetPipeNames failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.GetPipeNames failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.GetPipeNames failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

        /// <summary>
        /// Register to Event Callback to receive ACP Events.
        /// </summary>
        /// <param name="connectionName">Name of the connection.</param>
        /// <returns>
        /// <para>MLResult.Result will be <c>MLResult.Code.AllocFailed</c> if the registration resource allocation failed.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.InvalidParam</c> if a given argument is invalid.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.Ok</c> if successfully initialized.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.UnspecifiedFailure</c> if there was an unexpected failure.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.ConnectionsAlreadyRegistered</c> if this is a duplicate registration.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.ConnectionsNetworkFailure</c> if communication to the network failed.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.ConnectionsSystemFailure</c> if there was system failure.</para>
        /// </returns>
        public static MLResult RegisterEventCallback(string connectionName)
        {
            if (MLAppConnect.IsValidInstance())
            {
                try
                {
                    MLAppConnectNativeBindings.EventCallback eventCallbacks = MLAppConnectNativeBindings.EventCallback.Create();

                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectRegisterEventCallback(connectionName, ref eventCallbacks, ref eventHandle);
                    if (!MLResult.IsOK(resultCode) || !MagicLeapNativeBindings.MLHandleIsValid(inviteHandle))
                    {
                        MLResult resultError = MLResult.Create(resultCode);
                        MLPluginLog.ErrorFormat("MLAppConnect.OnConnection failed in RegisterEventCallback() to register to receive events. Handle is invalid or Reason: {0}", resultError);
                        return resultError;
                    }

                    return MLResult.Create(resultCode);
                }
                catch (EntryPointNotFoundException)
                {
                    MLPluginLog.Error("MLAppConnect.RegisterEventCallback failed. Reason: API symbols not found.");
                    return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.RegisterEventCallback failed. Reason: API symbols not found.");
                }
            }
            else
            {
                MLPluginLog.ErrorFormat("MLAppConnect.RegisterEventCallback failed. Reason: MLAppConnect.Start was not called or failed to Start.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.RegisterEventCallback failed. Reason: MLAppConnect.Start was not called or failed to Start.");
            }
        }

#if !DOXYGEN_SHOULD_SKIP_THIS

        /// <summary>
        /// Called by MLAPISingleton to start the API
        /// </summary>
        /// <returns>
        /// <para>MLResult.Result will be <c>MLResult.Code.AllocFailed</c> if the registration resource allocation failed.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.InvalidParam</c> if a given argument is invalid.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.Ok</c> if successfully initialized.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.UnspecifiedFailure</c> if there was an unexpected failure.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.ConnectionsAlreadyRegistered</c> if this is a duplicate registration.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.ConnectionsNetworkFailure</c> if communication to the network failed.</para>
        /// <para>MLResult.Result will be <c>MLResult.Code.ConnectionsSystemFailure</c> if there was system failure.</para>
        /// </returns>
        protected override MLResult StartAPI()
        {
            try
            {
                MLAppConnectNativeBindings.ConnectionCallback connectionCallbacks = MLAppConnectNativeBindings.ConnectionCallback.Create();

                MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectRegisterConnectionCallback(ref connectionCallbacks, ref connectionHandle);

                if (!MLResult.IsOK(resultCode) || !MagicLeapNativeBindings.MLHandleIsValid(connectionHandle))
                {
                    MLResult resultError = MLResult.Create(resultCode);

                    MLPluginLog.ErrorFormat("MLAppConnect.Start failed in StartAPI() to register to receive connection callbacks. Handle is invalid or Reason: {0}", resultError);

                    return resultError;
                }

                MLAppConnectNativeBindings.InviteCallback inviteCallbacks = MLAppConnectNativeBindings.InviteCallback.Create();

                resultCode = MLAppConnectNativeBindings.MLAppConnectRegisterInviteCallback(ref inviteCallbacks, ref inviteHandle);

                if (!MLResult.IsOK(resultCode) || !MagicLeapNativeBindings.MLHandleIsValid(inviteHandle))
                {
                    MLResult resultError = MLResult.Create(resultCode);

                    MLPluginLog.ErrorFormat("MLAppConnect.Start failed in StartAPI() to register to receive invites. Handle is invalid or Reason: {0}", resultError);

                    return resultError;
                }

                return MLResult.Create(resultCode);
            }
            catch (EntryPointNotFoundException)
            {
                MLPluginLog.Error("MLAppConnect.StartAPI failed. Reason: API symbols not found.");
                return MLResult.Create(MLResult.Code.UnspecifiedFailure, "MLAppConnect.StartAPI failed. Reason: API symbols not found.");
            }
        }
#endif // DOXYGEN_SHOULD_SKIP_THIS

        /// <summary>
        /// Update loop.
        /// </summary>
        protected override void Update()
        {
            if (videoThreadRunning && nextFrameReady)
            {
                UpdateVideoFrame();
            }
        }

        /// <summary>
        /// Called by MLAPISingleton on destruction
        /// </summary>
        /// <param name="isSafeToAccessManagedObjects">Used for cleanup.</param>
        protected override void CleanupAPI(bool isSafeToAccessManagedObjects)
        {
            try
            {
                if (!string.IsNullOrEmpty(ConnectionName))
                {
                    DeleteConnection();
                }

                if (videoThreadRunning)
                {
                    videoThreadRunning = false;
                    videoReadThread.Join();
                }

                if (MagicLeapNativeBindings.MLHandleIsValid(connectionHandle))
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectUnregisterConnectionCallback(connectionHandle);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLPluginLog.ErrorFormat("MLAppConnect.Stop failed in CleapupAPI() to shutdown unregister to connection callback. Reason: {0}", MLResult.CodeToString(resultCode));
                    }
                }

                if (MagicLeapNativeBindings.MLHandleIsValid(inviteHandle))
                {
                    MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectUnregisterInviteCallback(inviteHandle);

                    if (!MLResult.IsOK(resultCode))
                    {
                        MLPluginLog.ErrorFormat("MLAppConnect.Stop failed in CleapupAPI() to shutdown registration to receive invites. Reason: {0}", MLResult.CodeToString(resultCode));
                    }
                }

                connectionHandle = MagicLeapNativeBindings.InvalidHandle;
                inviteHandle = MagicLeapNativeBindings.InvalidHandle;
            }
            catch (EntryPointNotFoundException)
            {
                MLPluginLog.Error("MLAppConnect.CleanupAPI failed. Reason: API symbols not found.");
            }
        }

        /// <summary>
        /// Creates an Instance of the MLAppConnect class.
        /// </summary>
        private static void CreateInstance()
        {
            if (!MLAppConnect.IsValidInstance())
            {
                MLAppConnect._instance = new MLAppConnect();
            }
        }

        /// <summary>
        /// Frames for the specified video pipes will be read at regular intervals until #StopVideoFrameRead is called.
        /// </summary>
        private static void VideoThreadWork()
        {
            videoThreadRunning = true;
            //// This pattern lets us interrupt the work at a safe point if neeeded.
            while (videoThreadRunning)
            {
                if (!nextFrameReady && videoPipeNames.Count > 0)
                {
                    lock (balanceLock)
                    {
                        foreach (string pipeName in videoPipeNames)
                        {
                            VideoReadUpdate(pipeName);
                        }
                    }

                    nextFrameReady = true;
                }

                Thread.Sleep(20);
            }

            videoThreadRunning = false;
        }

        /// <summary>
        /// caches the video frame in frameData dictionary to be converted to a Texture in the next update cycle
        /// </summary>
        /// <param name="pipeName">Name of the pipe</param>
        private static void VideoReadUpdate(string pipeName)
        {
            try
            {

                MLResult.Code resultCode = MLAppConnectNativeBindings.MLAppConnectReadVideoFrame(ConnectionName, pipeName, true, out cachedNativeImage);

                if (!MLResult.IsOK(resultCode))
                {
                    cachedNativeImage.Image = IntPtr.Zero;
                    MLResult resultError = MLResult.Create(resultCode);
                    MLPluginLog.ErrorFormat("MLAppConnect.VideoReadUpdate failed to read frame, Reason: {0}", resultError);
                    return;
                }

                if (cachedNativeImage.Image != IntPtr.Zero)
                {
                    if (frameData.ContainsKey(pipeName))
                    {
                        frameData[pipeName].DataBuffer = new byte[frameData[pipeName].Size];
                        Marshal.Copy(cachedNativeImage.Image, frameData[pipeName].DataBuffer, 0, (int)frameData[pipeName].Size);
                    }
                    else
                    {
                        TextureFormat textureFormat = cachedNativeImage.ImageType == MLImageNativeBindings.MLImageType.RGB24 ? TextureFormat.RGB24 : TextureFormat.RGBA32;
                        uint size = cachedNativeImage.Width * cachedNativeImage.Height;
                        size = cachedNativeImage.ImageType == MLImageNativeBindings.MLImageType.RGB24 ? (size * 3) : (size * 4);

                        VideoFrameData videoFrame = new VideoFrameData
                        {
                            ImageFormat = textureFormat,
                            Size = size,
                            DataBuffer = new byte[size],
                            VideoFrame = new Texture2D((int)cachedNativeImage.Width, (int)cachedNativeImage.Height, TextureFormat.RGBA32, false, false)
                        };

                        if (frameData.TryAdd(pipeName, videoFrame))
                        {
                            frameData[pipeName].DataBuffer = new byte[frameData[pipeName].Size];
                            Marshal.Copy(cachedNativeImage.Image, frameData[pipeName].DataBuffer, 0, (int)frameData[pipeName].Size);
                        }
                    }
                }

                //// Free video frame allocated by #MLAppConnectReadVideoFrame()
                resultCode = MLAppConnectNativeBindings.MLAppConnectFreeVideoFrame(ref cachedNativeImage);

                if (!MLResult.IsOK(resultCode))
                {
                    cachedNativeImage.Image = IntPtr.Zero;
                    MLResult resultError = MLResult.Create(resultCode);
                    MLPluginLog.ErrorFormat("MLAppConnect.GetVideoFrame failed to free video frame after a successful read, Reason: {0}", resultError);
                }
            }
            catch (EntryPointNotFoundException)
            {
                MLPluginLog.Error("MLAppConnect.VideoReadUpdate failed. Reason: API symbols not found.");
            }
        }

        /// <summary>
        /// The cached MLImage will be converted into a Texture2D if the next frame is ready to be updated.
        /// </summary>
        private static void UpdateVideoFrame()
        {
            lock (balanceLock)
            {
                foreach (string pipeName in videoPipeNames)
                {
                    if (frameData.ContainsKey(pipeName) && frameData[pipeName].DataBuffer != null)
                    {
                        frameData[pipeName].VideoFrame.LoadRawTextureData(frameData[pipeName].DataBuffer);
                        frameData[pipeName].VideoFrame.Apply();
                        frameData[pipeName].DataBuffer = null;
                        MLThreadDispatch.Call(pipeName, frameData[pipeName].VideoFrame, OnVideoFrameUpdate);
                    }
                    else
                    {
                        MLPluginLog.ErrorFormat("Video Frame failed to update for pipe {0} because MLImageNative is empty", pipeName);
                    }
                }
            }

            nextFrameReady = false;
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectConnectionProperties from #ml_app_connect.h.
        /// The connection properties of a AppConnect connection.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct ConnectionProperties
        {
            /// <summary
            /// >Version of this structure.
            /// </summary>
            public uint Version;

            /// <summary
            /// >The connection type to create a connection.
            /// </summary>
            public MLAppConnect.ConnectionType Type;

            /// <summary>
            /// The priority level of this connection.
            /// </summary>
            public MLAppConnect.Priority Priority;

            /// <summary>
            /// Max participants per connection. It may be any number between 2 and #MLAppConnectConnectionMaxParticipants
            /// </summary>
            public uint MaxParticipants;

            /// <summary>
            /// Lock remote connections from inviting contacts.
            /// </summary>
            [MarshalAs(UnmanagedType.I1)]
            public bool LockContacts;

            /// <summary>
            /// Lock remote connections from creating/deleting pipes.
            /// </summary>
            [MarshalAs(UnmanagedType.I1)]
            public bool LockPipes;

            /// <summary>
            /// Initializes a new instance of ConnectionProperties.
            /// </summary>
            /// <returns>
            /// Instance of MLAppConnectConnectionProperties object.
            /// </returns>
            public static ConnectionProperties Create()
            {
                return new ConnectionProperties()
                {
                    Version = 1,
                    Type = MLAppConnect.ConnectionType.Default,
                    Priority = MLAppConnect.Priority.Normal,
                    MaxParticipants = ConnectionMaxParticipants,
                    LockContacts = true,
                    LockPipes = true
                };
            }
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectPipeProperties from #ml_app_connect.h.
        /// Pipe Properties
        /// </summary>
        public struct PipeProperties
        {
            /// <summary>
            /// The pipe type to create a pipe.
            /// </summary>
            public PipeType Type;

            /// <summary>
            /// The directionality (bi-direction, <c>uni-direction</c> in, out) of the pipe.
            /// </summary>
            public PipeDirection Direction;

            /// <summary>
            /// The priority level of this pipe (relative to connection).
            /// </summary>
            public Priority Priority;
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectDataPipeProperties from #ml_app_connect.h.
        /// Data Pipe Properties.
        /// </summary>
        public struct DataPipeProperties
        {
            /// <summary>
            /// Version of this structure.
            /// </summary>
            public uint Version;

            /// <summary>
            /// The base pipe properties.
            /// </summary>
            public PipeProperties BasePipe;

            /// <summary>
            /// The reliability requirements of the pipe.
            /// </summary>
            public PipeReliability Reliability;

            /// <summary>
            /// The packet ordering requirements of the pipe.
            /// </summary>
            public PipeOrdering Ordering;

            /// <summary>
            /// The buffer size (memory allocation) for the pipe's queue(s).
            /// </summary>
            public long BufferSize;

            /// <summary>
            /// Initializes a new instance of ConnectionProperties.
            /// </summary>
            /// <returns>
            /// Instance of MLAppConnectConnectionProperties object.
            /// </returns>
            public static DataPipeProperties Create()
            {
                return new DataPipeProperties()
                {
                    Version = 1,
                    BasePipe = new PipeProperties()
                    {
                        Type = PipeType.DataPipe,
                        Direction = PipeDirection.BiDirectional,
                        Priority = Priority.Normal
                    },
                    Reliability = PipeReliability.Reliable,
                    Ordering = PipeOrdering.Ordered,
                    BufferSize = 4096
                };
            }
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectVideoDataProperties from #ml_app_connect.h.
        /// Video data properties.
        /// </summary>
        public struct VideoPipeProperties
        {
            /// <summary>
            /// Version of this structure.
            /// </summary>
            public uint Version;

            /// <summary>
            /// The base pipe properties.
            /// </summary>
            public PipeProperties BasePipe;

            /// <summary>
            /// Preferred width of the frame.
            /// </summary>
            public uint Width;

            /// <summary>
            /// Preferred height of the frame.
            /// </summary>
            public uint Height;

            /// <summary>
            /// Maximum width supported by the pipe.
            /// It must be a multiple of 16.
            /// </summary>
            public uint MaxWidth;

            /// <summary>
            /// Maximum height supported by the pipe.
            /// It must be a multiple of 16.
            /// </summary>
            public uint MaxHeight;

            /// <summary>
            /// Rate at which frames are send in this pipe.
            /// </summary>
            public uint Framerate;

            /// <summary>
            /// Video format.
            /// This is ignored for video capture pipe.
            /// </summary>
            public VideoFormat Format;

            /// <summary>
            /// Initializes a new instance of VideoPipeProperties.
            /// </summary>
            /// <returns>
            /// Instance of MLAppConnectVideoPipeProperties object.
            /// </returns>
            public static VideoPipeProperties Create()
            {
                return new VideoPipeProperties()
                {
                    Version = 1,
                    BasePipe = new PipeProperties()
                    {
                        Type = PipeType.VideoPipe,
                        Direction = PipeDirection.BiDirectional,
                        Priority = Priority.Normal
                    },
                    Width = 640,
                    Height = 480,
                    MaxWidth = 640,
                    MaxHeight = 480,
                    Framerate = 25,
                    Format = VideoFormat.RGBA
                };
            }
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectConnectionInfo from #ml_app_connect.h.
        /// Connection info in a connection callback MLAppConnectConnectionCallback().
        /// this structure contains unmanaged data and is for  internal use only.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct ConnectionInfo
        {
            /// <summary>
            /// Version of this structure.
            /// </summary>
            public uint Version;

            /// <summary>
            /// Name of the connection for which the callback is received.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string ConnectionName;

            /// <summary>
            /// Result of an operation performed.
            /// The values are defined in enum #MLAppConnectResult.
            /// </summary>
            public MLResult.Code Result;
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectPipeEventInfo from #ml_app_connect.h.
        /// Information about a pipe from the connection event callback (#MLAppConnectEventCallback()).
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct PipeEventInfo
        {
            /// <summary>
            /// Version of this structure.
            /// </summary>
            public uint Version;

            /// <summary>
            /// Name of a pipe.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string PipeName;

            /// <summary>
            /// Owner of a pipe.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string PipeOwner;

            /// <summary>
            /// Type of a pipe.
            /// </summary>
            public MLAppConnect.PipeType PipeType;

            /// <summary>
            /// Direction of a pipe.
            /// </summary>
            public MLAppConnect.PipeDirection PipeDirection;

            /// <summary>
            /// Status of the pipe.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string Status;
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectUserEventInfo from #ml_app_connect.h.
        /// Information about a user from the connection event callback (#MLAppConnectEventCallback()).
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct UserEventInfo
        {
            /// <summary>
            /// Version of this structure.
            /// </summary>
            public uint Version;

            /// <summary>
            /// Name of the user for which the changes have occurred.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string UserName;

            /// <summary>
            /// Status of the user.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string Status;
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectMicrophoneEventInfo from #ml_app_connect.h.
        /// Information about a user from the connection event callback (#MLAppConnectEventCallback()).
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MicrophoneEventInfo
        {
            /// <summary>
            /// Version of this structure.
            /// </summary>
            public uint Version;

            /// <summary>
            /// Name of the user for which the changes have occurred.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string UserName;
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectKeyValue from #ml_app_connect.h.
        /// This can be used to create key-value maps
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct KeyValue
        {
            /// <summary>
            /// Key of the pair.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string Key;

            /// <summary>
            /// Value of the pair.
            /// </summary>
            [MarshalAs(UnmanagedType.LPStr)]
            public string Value;
        }

        /// <summary>
        /// This is the C# representation of MLAppConnectConnectionEventInfo from #ml_app_connect.h.
        /// Event info.
        /// Top level structure with information from the connection event callback (#MLAppConnectEventCallback()).
        /// It contains child structures with specific information for each type of event.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct EventInfo
        {
            /// <summary>
            /// Version of this structure.
            /// </summary>
            public uint Version;

            /// <summary>
            /// Event type.
            /// </summary>
            public EventType EventName;

            /// <summary>
            /// Connection name.
            /// </summary>
            public string ConnectionName;

            /// <summary>
            /// Pipe Information.
            /// </summary>
            public PipeEventInfo PipeInfo;

            /// <summary>
            /// User Information.
            /// </summary>
            public UserEventInfo UserInfo;

            /// <summary>
            /// Microphone Information.
            /// </summary>
            public MicrophoneEventInfo MicrophoneInfo;
        }

        /// <summary>
        /// Class used to cache Video Frame Data.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        private class VideoFrameData
        {
            /// <summary>
            /// To determine if the Image is RGB or RGBA
            /// </summary>
            public TextureFormat ImageFormat;

            /// <summary>
            /// The size of the data buffer
            /// </summary>
            public uint Size;

            /// <summary>
            /// The pixel Data of the video frame
            /// </summary>
            public byte[] DataBuffer;

            /// <summary>
            /// the created texture;
            /// </summary>
            public Texture2D VideoFrame;
        }
#endif
    }
}
